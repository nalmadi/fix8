<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>driftAlgorithms &#8212; fix8 2024 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=6fefd858"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for driftAlgorithms</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="c1"># from sklearn.cluster import KMeans</span>

<span class="c1">######################################################################</span>
<span class="c1"># ATTACH</span>
<span class="c1">######################################################################</span>

<div class="viewcode-block" id="attach">
<a class="viewcode-back" href="../source/driftAlgorithms.html#driftAlgorithms.attach">[docs]</a>
<span class="k">def</span> <span class="nf">attach</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">,</span> <span class="n">line_Y</span><span class="p">):</span>
	<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">fixation_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
		<span class="n">line_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">line_Y</span> <span class="o">-</span> <span class="n">fixation_XY</span><span class="p">[</span><span class="n">fixation_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
		<span class="n">fixation_XY</span><span class="p">[</span><span class="n">fixation_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">line_Y</span><span class="p">[</span><span class="n">line_i</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">fixation_XY</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># CHAIN</span>
<span class="c1"># </span>
<span class="c1"># https://github.com/sascha2schroeder/popEye/</span>
<span class="c1">######################################################################</span>

<div class="viewcode-block" id="chain">
<a class="viewcode-back" href="../source/driftAlgorithms.html#driftAlgorithms.chain">[docs]</a>
<span class="k">def</span> <span class="nf">chain</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">,</span> <span class="n">line_Y</span><span class="p">,</span> <span class="n">x_thresh</span><span class="o">=</span><span class="mi">192</span><span class="p">,</span> <span class="n">y_thresh</span><span class="o">=</span><span class="mi">32</span><span class="p">):</span>
	<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">)</span>
	<span class="n">dist_X</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
	<span class="n">dist_Y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
	<span class="n">end_chain_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">dist_X</span> <span class="o">&gt;</span> <span class="n">x_thresh</span><span class="p">,</span> <span class="n">dist_Y</span> <span class="o">&gt;</span> <span class="n">y_thresh</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
	<span class="n">end_chain_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
	<span class="n">start_of_chain</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="n">end_of_chain</span> <span class="ow">in</span> <span class="n">end_chain_indices</span><span class="p">:</span>
		<span class="n">mean_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">[</span><span class="n">start_of_chain</span><span class="p">:</span><span class="n">end_of_chain</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
		<span class="n">line_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">line_Y</span> <span class="o">-</span> <span class="n">mean_y</span><span class="p">))</span>
		<span class="n">fixation_XY</span><span class="p">[</span><span class="n">start_of_chain</span><span class="p">:</span><span class="n">end_of_chain</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">line_Y</span><span class="p">[</span><span class="n">line_i</span><span class="p">]</span>
		<span class="n">start_of_chain</span> <span class="o">=</span> <span class="n">end_of_chain</span>
	<span class="k">return</span> <span class="n">fixation_XY</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># CLUSTER</span>
<span class="c1"># </span>
<span class="c1"># https://github.com/sascha2schroeder/popEye/</span>
<span class="c1">######################################################################</span>
<span class="c1"># added implementation of KMeans instead of using sklearn</span>
<div class="viewcode-block" id="KMeans">
<a class="viewcode-back" href="../source/driftAlgorithms.html#driftAlgorithms.KMeans">[docs]</a>
<span class="k">def</span> <span class="nf">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
	<span class="k">def</span> <span class="nf">fit_predict</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
		<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
		<span class="n">centers</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>
		<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_init</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
				<span class="n">cluster_assignments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">centers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">new_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">X</span><span class="p">[</span><span class="n">cluster_assignments</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)])</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">centers</span> <span class="o">==</span> <span class="n">new_centers</span><span class="p">):</span>
					<span class="k">break</span>
				<span class="n">centers</span> <span class="o">=</span> <span class="n">new_centers</span>
		<span class="k">return</span> <span class="n">cluster_assignments</span>
	<span class="k">return</span> <span class="n">fit_predict</span></div>


<div class="viewcode-block" id="cluster">
<a class="viewcode-back" href="../source/driftAlgorithms.html#driftAlgorithms.cluster">[docs]</a>
<span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">,</span> <span class="n">line_Y</span><span class="p">):</span>
	<span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line_Y</span><span class="p">)</span>
	<span class="n">fixation_Y</span> <span class="o">=</span> <span class="n">fixation_XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="c1"># clusters = KMeans(m, n_init=100, max_iter=300).fit_predict(fixation_Y)</span>
	<span class="n">clusters</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">300</span><span class="p">)(</span><span class="n">fixation_Y</span><span class="p">)</span>
	<span class="n">centers</span> <span class="o">=</span> <span class="p">[</span><span class="n">fixation_Y</span><span class="p">[</span><span class="n">clusters</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
	<span class="n">ordered_cluster_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">fixation_i</span><span class="p">,</span> <span class="n">cluster_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">):</span>
		<span class="n">line_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ordered_cluster_indices</span> <span class="o">==</span> <span class="n">cluster_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">fixation_XY</span><span class="p">[</span><span class="n">fixation_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">line_Y</span><span class="p">[</span><span class="n">line_i</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">fixation_XY</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># COMPARE</span>
<span class="c1">#</span>
<span class="c1"># Lima Sanches, C., Kise, K., &amp; Augereau, O. (2015). Eye gaze and text</span>
<span class="c1">#   line matching for reading analysis. In Adjunct proceedings of the</span>
<span class="c1">#   2015 ACM International Joint Conference on Pervasive and</span>
<span class="c1">#   Ubiquitous Computing and proceedings of the 2015 ACM International</span>
<span class="c1">#   Symposium on Wearable Computers (pp. 1227–1233). Association for</span>
<span class="c1">#   Computing Machinery.</span>
<span class="c1">#</span>
<span class="c1"># https://doi.org/10.1145/2800835.2807936</span>
<span class="c1">######################################################################</span>

<div class="viewcode-block" id="compare">
<a class="viewcode-back" href="../source/driftAlgorithms.html#driftAlgorithms.compare">[docs]</a>
<span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">,</span> <span class="n">word_XY</span><span class="p">,</span> <span class="n">x_thresh</span><span class="o">=</span><span class="mi">75</span><span class="p">,</span> <span class="n">n_nearest_lines</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
	<span class="n">line_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">word_XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
	<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">)</span>
	<span class="n">diff_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
	<span class="n">end_line_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff_X</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">x_thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
	<span class="n">end_line_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
	<span class="n">start_of_line</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="n">end_of_line</span> <span class="ow">in</span> <span class="n">end_line_indices</span><span class="p">:</span>
		<span class="n">gaze_line</span> <span class="o">=</span> <span class="n">fixation_XY</span><span class="p">[</span><span class="n">start_of_line</span><span class="p">:</span><span class="n">end_of_line</span><span class="p">]</span>
		<span class="n">mean_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">gaze_line</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
		<span class="n">lines_ordered_by_proximity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">line_Y</span> <span class="o">-</span> <span class="n">mean_y</span><span class="p">))</span>
		<span class="n">nearest_line_I</span> <span class="o">=</span> <span class="n">lines_ordered_by_proximity</span><span class="p">[:</span><span class="n">n_nearest_lines</span><span class="p">]</span>
		<span class="n">line_costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_nearest_lines</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">candidate_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nearest_lines</span><span class="p">):</span>
			<span class="n">candidate_line_i</span> <span class="o">=</span> <span class="n">nearest_line_I</span><span class="p">[</span><span class="n">candidate_i</span><span class="p">]</span>
			<span class="n">text_line</span> <span class="o">=</span> <span class="n">word_XY</span><span class="p">[</span><span class="n">word_XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">line_Y</span><span class="p">[</span><span class="n">candidate_line_i</span><span class="p">]]</span>
			<span class="n">dtw_cost</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">dynamic_time_warping</span><span class="p">(</span><span class="n">gaze_line</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">text_line</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">line_costs</span><span class="p">[</span><span class="n">candidate_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtw_cost</span>
		<span class="n">line_i</span> <span class="o">=</span> <span class="n">nearest_line_I</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">line_costs</span><span class="p">)]</span>
		<span class="n">fixation_XY</span><span class="p">[</span><span class="n">start_of_line</span><span class="p">:</span><span class="n">end_of_line</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">line_Y</span><span class="p">[</span><span class="n">line_i</span><span class="p">]</span>
		<span class="n">start_of_line</span> <span class="o">=</span> <span class="n">end_of_line</span>
	<span class="c1"># print(fixation_XY)</span>
	<span class="k">return</span> <span class="n">fixation_XY</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># MERGE</span>
<span class="c1">#</span>
<span class="c1"># Špakov, O., Istance, H., Hyrskykari, A., Siirtola, H., &amp; Räihä,</span>
<span class="c1">#   K.-J. (2019). Improving the performance of eye trackers with</span>
<span class="c1">#   limited spatial accuracy and low sampling rates for reading</span>
<span class="c1">#   analysis by heuristic fixation-to-word mapping. Behavior Research</span>
<span class="c1">#   Methods, 51(6), 2661–2687.</span>
<span class="c1">#</span>
<span class="c1"># https://doi.org/10.3758/s13428-018-1120-x</span>
<span class="c1"># https://github.com/uta-gasp/sgwm</span>
<span class="c1">######################################################################</span>

<span class="n">phases</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;min_i&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;min_j&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;no_constraints&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">},</span> <span class="c1"># Phase 1</span>
          <span class="p">{</span><span class="s1">&#39;min_i&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;min_j&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;no_constraints&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">},</span> <span class="c1"># Phase 2</span>
          <span class="p">{</span><span class="s1">&#39;min_i&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;min_j&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;no_constraints&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">},</span> <span class="c1"># Phase 3</span>
          <span class="p">{</span><span class="s1">&#39;min_i&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;min_j&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;no_constraints&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}]</span>  <span class="c1"># Phase 4</span>

<div class="viewcode-block" id="merge">
<a class="viewcode-back" href="../source/driftAlgorithms.html#driftAlgorithms.merge">[docs]</a>
<span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">,</span> <span class="n">line_Y</span><span class="p">,</span> <span class="n">y_thresh</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">g_thresh</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">e_thresh</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
	<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">)</span>
	<span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line_Y</span><span class="p">)</span>
	<span class="n">diff_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
	<span class="n">dist_Y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
	<span class="n">sequence_boundaries</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">diff_X</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dist_Y</span> <span class="o">&gt;</span> <span class="n">y_thresh</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
	<span class="n">sequence_starts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sequence_boundaries</span>
	<span class="n">sequence_ends</span> <span class="o">=</span> <span class="n">sequence_boundaries</span> <span class="o">+</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
	<span class="n">sequences</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sequence_starts</span><span class="p">,</span> <span class="n">sequence_ends</span><span class="p">)]</span>
	<span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">:</span>
		<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
			<span class="n">best_merger</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="n">best_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">phase</span><span class="p">[</span><span class="s1">&#39;min_i&#39;</span><span class="p">]:</span>
					<span class="k">continue</span> <span class="c1"># first sequence too short, skip to next i</span>
				<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequences</span><span class="p">)):</span>
					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequences</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">phase</span><span class="p">[</span><span class="s1">&#39;min_j&#39;</span><span class="p">]:</span>
						<span class="k">continue</span> <span class="c1"># second sequence too short, skip to next j</span>
					<span class="n">candidate_XY</span> <span class="o">=</span> <span class="n">fixation_XY</span><span class="p">[</span><span class="n">sequences</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">sequences</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
					<span class="n">gradient</span><span class="p">,</span> <span class="n">intercept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">candidate_XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">candidate_XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
					<span class="n">residuals</span> <span class="o">=</span> <span class="n">candidate_XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">gradient</span> <span class="o">*</span> <span class="n">candidate_XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">intercept</span><span class="p">)</span>
					<span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">residuals</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate_XY</span><span class="p">))</span>
					<span class="k">if</span> <span class="n">phase</span><span class="p">[</span><span class="s1">&#39;no_constraints&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">g_thresh</span> <span class="ow">and</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">e_thresh</span><span class="p">):</span>
						<span class="k">if</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">best_error</span><span class="p">:</span>
							<span class="n">best_merger</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
							<span class="n">best_error</span> <span class="o">=</span> <span class="n">error</span>
			<span class="k">if</span> <span class="n">best_merger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="k">break</span> <span class="c1"># no possible mergers, break while and move to next phase</span>
			<span class="n">merge_i</span><span class="p">,</span> <span class="n">merge_j</span> <span class="o">=</span> <span class="n">best_merger</span>
			<span class="n">merged_sequence</span> <span class="o">=</span> <span class="n">sequences</span><span class="p">[</span><span class="n">merge_i</span><span class="p">]</span> <span class="o">+</span> <span class="n">sequences</span><span class="p">[</span><span class="n">merge_j</span><span class="p">]</span>
			<span class="n">sequences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">merged_sequence</span><span class="p">)</span>
			<span class="k">del</span> <span class="n">sequences</span><span class="p">[</span><span class="n">merge_j</span><span class="p">],</span> <span class="n">sequences</span><span class="p">[</span><span class="n">merge_i</span><span class="p">]</span>
	<span class="n">mean_Y</span> <span class="o">=</span> <span class="p">[</span><span class="n">fixation_XY</span><span class="p">[</span><span class="n">sequence</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">for</span> <span class="n">sequence</span> <span class="ow">in</span> <span class="n">sequences</span><span class="p">]</span>
	<span class="n">ordered_sequence_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">mean_Y</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">line_i</span><span class="p">,</span> <span class="n">sequence_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ordered_sequence_indices</span><span class="p">):</span>
		<span class="n">fixation_XY</span><span class="p">[</span><span class="n">sequences</span><span class="p">[</span><span class="n">sequence_i</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">line_Y</span><span class="p">[</span><span class="n">line_i</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">fixation_XY</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># REGRESS</span>
<span class="c1">#</span>
<span class="c1"># Cohen, A. L. (2013). Software for the automatic correction of</span>
<span class="c1">#   recorded eye fixation locations in reading experiments. Behavior</span>
<span class="c1">#   Research Methods, 45(3), 679–683.</span>
<span class="c1">#</span>
<span class="c1"># https://doi.org/10.3758/s13428-012-0280-3</span>
<span class="c1"># https://blogs.umass.edu/rdcl/resources/</span>
<span class="c1">######################################################################</span>

<div class="viewcode-block" id="regress">
<a class="viewcode-back" href="../source/driftAlgorithms.html#driftAlgorithms.regress">[docs]</a>
<span class="k">def</span> <span class="nf">regress</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">,</span> <span class="n">line_Y</span><span class="p">,</span> <span class="n">k_bounds</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">o_bounds</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">s_bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)):</span>
	<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">)</span>
	<span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line_Y</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">fit_lines</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">return_line_assignments</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="n">k</span> <span class="o">=</span> <span class="n">k_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">k_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">k_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">o</span> <span class="o">=</span> <span class="n">o_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">o_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">o_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">s_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">s_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
		<span class="n">predicted_Y_from_slope</span> <span class="o">=</span> <span class="n">fixation_XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span>
		<span class="n">line_Y_plus_offset</span> <span class="o">=</span> <span class="n">line_Y</span> <span class="o">+</span> <span class="n">o</span>
		<span class="n">density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
		<span class="k">for</span> <span class="n">line_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
			<span class="n">fit_Y</span> <span class="o">=</span> <span class="n">predicted_Y_from_slope</span> <span class="o">+</span> <span class="n">line_Y_plus_offset</span><span class="p">[</span><span class="n">line_i</span><span class="p">]</span>
			<span class="n">density</span><span class="p">[:,</span> <span class="n">line_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fit_Y</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">return_line_assignments</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">density</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="n">density</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

	<span class="n">best_fit</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">fit_lines</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
	<span class="n">line_assignments</span> <span class="o">=</span> <span class="n">fit_lines</span><span class="p">(</span><span class="n">best_fit</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">fixation_i</span><span class="p">,</span> <span class="n">line_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line_assignments</span><span class="p">):</span>
		<span class="n">fixation_XY</span><span class="p">[</span><span class="n">fixation_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">line_Y</span><span class="p">[</span><span class="n">line_i</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">fixation_XY</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># SEGMENT</span>
<span class="c1">#</span>
<span class="c1"># Abdulin, E. R., &amp; Komogortsev, O. V. (2015). Person verification via</span>
<span class="c1">#   eye movement-driven text reading model, In 2015 IEEE 7th</span>
<span class="c1">#   International Conference on Biometrics Theory, Applications and</span>
<span class="c1">#   Systems. IEEE.</span>
<span class="c1">#</span>
<span class="c1"># https://doi.org/10.1109/BTAS.2015.7358786</span>
<span class="c1">######################################################################</span>

<div class="viewcode-block" id="segment">
<a class="viewcode-back" href="../source/driftAlgorithms.html#driftAlgorithms.segment">[docs]</a>
<span class="k">def</span> <span class="nf">segment</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">,</span> <span class="n">line_Y</span><span class="p">):</span>
	<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">)</span>
	<span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line_Y</span><span class="p">)</span>
	<span class="n">diff_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
	<span class="n">saccades_ordered_by_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">diff_X</span><span class="p">)</span>
	<span class="n">line_change_indices</span> <span class="o">=</span> <span class="n">saccades_ordered_by_length</span><span class="p">[:</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="n">current_line_i</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="n">fixation_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
		<span class="n">fixation_XY</span><span class="p">[</span><span class="n">fixation_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">line_Y</span><span class="p">[</span><span class="n">current_line_i</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">fixation_i</span> <span class="ow">in</span> <span class="n">line_change_indices</span><span class="p">:</span>
			<span class="n">current_line_i</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="k">return</span> <span class="n">fixation_XY</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># SLICE</span>
<span class="c1">#</span>
<span class="c1"># Glandorf, D., &amp; Schroeder, S. (2021). Slice: An algorithm to assign</span>
<span class="c1">#   fixations in multi-line texts. Procedia Computer Science, 192,</span>
<span class="c1">#   2971–2979.</span>
<span class="c1">#</span>
<span class="c1"># https://doi.org/10.1016/j.procs.2021.09.069</span>
<span class="c1">######################################################################</span>

<div class="viewcode-block" id="slice">
<a class="viewcode-back" href="../source/driftAlgorithms.html#driftAlgorithms.slice">[docs]</a>
<span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">,</span> <span class="n">line_Y</span><span class="p">,</span> <span class="n">x_thresh</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">y_thresh</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">w_thresh</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">n_thresh</span><span class="o">=</span><span class="mi">90</span><span class="p">):</span>
	<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">)</span>
	<span class="n">line_height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">line_Y</span><span class="p">))</span>
	<span class="n">proto_lines</span><span class="p">,</span> <span class="n">phantom_proto_lines</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
	<span class="c1"># 1. Segment runs</span>
	<span class="n">dist_X</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
	<span class="n">dist_Y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
	<span class="n">end_run_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">dist_X</span> <span class="o">&gt;</span> <span class="n">x_thresh</span><span class="p">,</span> <span class="n">dist_Y</span> <span class="o">&gt;</span> <span class="n">y_thresh</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
	<span class="n">run_starts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">end_run_indices</span>
	<span class="n">run_ends</span> <span class="o">=</span> <span class="n">end_run_indices</span> <span class="o">+</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
	<span class="n">runs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">run_starts</span><span class="p">,</span> <span class="n">run_ends</span><span class="p">)]</span>
	<span class="c1"># 2. Determine starting run</span>
	<span class="n">longest_run_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">([</span><span class="n">fixation_XY</span><span class="p">[</span><span class="n">run</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">fixation_XY</span><span class="p">[</span><span class="n">run</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="n">runs</span><span class="p">])</span>
	<span class="n">proto_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">runs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">longest_run_i</span><span class="p">)</span>
	<span class="c1"># 3. Group runs into proto lines</span>
	<span class="k">while</span> <span class="n">runs</span><span class="p">:</span>
		<span class="n">merger_on_this_iteration</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="k">for</span> <span class="n">proto_line_i</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">[(</span><span class="nb">min</span><span class="p">(</span><span class="n">proto_lines</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">proto_lines</span><span class="p">),</span> <span class="mi">1</span><span class="p">)]:</span>
			<span class="c1"># Create new proto line above or below (depending on direction)</span>
			<span class="n">proto_lines</span><span class="p">[</span><span class="n">proto_line_i</span> <span class="o">+</span> <span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="c1"># Get current proto line XY coordinates (if proto line is empty, get phanton coordinates)</span>
			<span class="k">if</span> <span class="n">proto_lines</span><span class="p">[</span><span class="n">proto_line_i</span><span class="p">]:</span>
				<span class="n">proto_line_XY</span> <span class="o">=</span> <span class="n">fixation_XY</span><span class="p">[</span><span class="n">proto_lines</span><span class="p">[</span><span class="n">proto_line_i</span><span class="p">]]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">proto_line_XY</span> <span class="o">=</span> <span class="n">phantom_proto_lines</span><span class="p">[</span><span class="n">proto_line_i</span><span class="p">]</span>
			<span class="c1"># Compute differences between current proto line and all runs</span>
			<span class="n">run_differences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">runs</span><span class="p">))</span>
			<span class="k">for</span> <span class="n">run_i</span><span class="p">,</span> <span class="n">run</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">runs</span><span class="p">):</span>
				<span class="n">y_diffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="n">proto_line_XY</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">proto_line_XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)),</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">fixation_XY</span><span class="p">[</span><span class="n">run</span><span class="p">]]</span>
				<span class="n">run_differences</span><span class="p">[</span><span class="n">run_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_diffs</span><span class="p">)</span>
			<span class="c1"># Find runs that can be merged into this proto line</span>
			<span class="n">merge_into_current</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">run_differences</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">w_thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
			<span class="c1"># Find runs that can be merged into the adjacent proto line</span>
			<span class="n">merge_into_adjacent</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
				<span class="n">run_differences</span> <span class="o">*</span> <span class="n">direction</span> <span class="o">&gt;=</span> <span class="n">w_thresh</span><span class="p">,</span>
				<span class="n">run_differences</span> <span class="o">*</span> <span class="n">direction</span> <span class="o">&lt;</span> <span class="n">n_thresh</span>
			<span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
			<span class="c1"># Perform mergers</span>
			<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">merge_into_current</span><span class="p">:</span>
				<span class="n">proto_lines</span><span class="p">[</span><span class="n">proto_line_i</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">runs</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
			<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">merge_into_adjacent</span><span class="p">:</span>
				<span class="n">proto_lines</span><span class="p">[</span><span class="n">proto_line_i</span> <span class="o">+</span> <span class="n">direction</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">runs</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
			<span class="c1"># If no, mergers to the adjacent, create phantom line for the adjacent</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">merge_into_adjacent</span><span class="p">:</span>
				<span class="n">average_x</span><span class="p">,</span> <span class="n">average_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">proto_line_XY</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
				<span class="n">adjacent_y</span> <span class="o">=</span> <span class="n">average_y</span> <span class="o">+</span> <span class="n">line_height</span> <span class="o">*</span> <span class="n">direction</span>
				<span class="n">phantom_proto_lines</span><span class="p">[</span><span class="n">proto_line_i</span> <span class="o">+</span> <span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">average_x</span><span class="p">,</span> <span class="n">adjacent_y</span><span class="p">]])</span>
			<span class="c1"># Remove all runs that were merged on this iteration</span>
			<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">merge_into_current</span> <span class="o">+</span> <span class="n">merge_into_adjacent</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
				<span class="k">del</span> <span class="n">runs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
				<span class="n">merger_on_this_iteration</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="c1"># If no mergers were made, break the while loop</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">merger_on_this_iteration</span><span class="p">:</span>
			<span class="k">break</span>
	<span class="c1"># 4. Assign any leftover runs to the closest proto lines</span>
	<span class="k">for</span> <span class="n">run</span> <span class="ow">in</span> <span class="n">runs</span><span class="p">:</span>
		<span class="n">best_pl_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
		<span class="n">best_pl_assignemnt</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">for</span> <span class="n">proto_line_i</span> <span class="ow">in</span> <span class="n">proto_lines</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">proto_lines</span><span class="p">[</span><span class="n">proto_line_i</span><span class="p">]:</span>
				<span class="n">proto_line_XY</span> <span class="o">=</span> <span class="n">fixation_XY</span><span class="p">[</span><span class="n">proto_lines</span><span class="p">[</span><span class="n">proto_line_i</span><span class="p">]]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">proto_line_XY</span> <span class="o">=</span> <span class="n">phantom_proto_lines</span><span class="p">[</span><span class="n">proto_line_i</span><span class="p">]</span>
			<span class="n">y_diffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="n">proto_line_XY</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">proto_line_XY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)),</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">fixation_XY</span><span class="p">[</span><span class="n">run</span><span class="p">]]</span>
			<span class="n">pl_distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_diffs</span><span class="p">))</span>
			<span class="k">if</span> <span class="n">pl_distance</span> <span class="o">&lt;</span> <span class="n">best_pl_distance</span><span class="p">:</span>
				<span class="n">best_pl_distance</span> <span class="o">=</span> <span class="n">pl_distance</span>
				<span class="n">best_pl_assignemnt</span> <span class="o">=</span> <span class="n">proto_line_i</span>
		<span class="n">proto_lines</span><span class="p">[</span><span class="n">best_pl_assignemnt</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">run</span><span class="p">)</span>
	<span class="c1"># 5. Prune proto lines</span>
	<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">proto_lines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">line_Y</span><span class="p">):</span>
		<span class="n">top</span><span class="p">,</span> <span class="n">bot</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">proto_lines</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">proto_lines</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">proto_lines</span><span class="p">[</span><span class="n">top</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">proto_lines</span><span class="p">[</span><span class="n">bot</span><span class="p">]):</span>
			<span class="n">proto_lines</span><span class="p">[</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">proto_lines</span><span class="p">[</span><span class="n">top</span><span class="p">])</span>
			<span class="k">del</span> <span class="n">proto_lines</span><span class="p">[</span><span class="n">top</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">proto_lines</span><span class="p">[</span><span class="n">bot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">proto_lines</span><span class="p">[</span><span class="n">bot</span><span class="p">])</span>
			<span class="k">del</span> <span class="n">proto_lines</span><span class="p">[</span><span class="n">bot</span><span class="p">]</span>
	<span class="c1"># 6. Map proto lines to text lines</span>
	<span class="k">for</span> <span class="n">line_i</span><span class="p">,</span> <span class="n">proto_line_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">proto_lines</span><span class="p">)):</span>
		<span class="n">fixation_XY</span><span class="p">[</span><span class="n">proto_lines</span><span class="p">[</span><span class="n">proto_line_i</span><span class="p">],</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">line_Y</span><span class="p">[</span><span class="n">line_i</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">fixation_XY</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># SPLIT</span>
<span class="c1">#</span>
<span class="c1"># Carr, J. W., Pescuma, V. N., Furlan, M., Ktori, M., &amp; Crepaldi, D.</span>
<span class="c1">#   (2021). Algorithms for the automated correction of vertical drift</span>
<span class="c1">#   in eye-tracking data. Behavior Research Methods.</span>
<span class="c1">#</span>
<span class="c1"># https://doi.org/10.3758/s13428-021-01554-0</span>
<span class="c1"># https://github.com/jwcarr/drift</span>
<span class="c1">######################################################################</span>

<span class="c1"># def split(fixation_XY, line_Y):</span>
<span class="c1"># 	n = len(fixation_XY)</span>
<span class="c1"># 	diff_X = np.diff(fixation_XY[:, 0])</span>
<span class="c1"># 	clusters = KMeans(2, n_init=10, max_iter=300).fit_predict(diff_X.reshape(-1, 1))</span>
<span class="c1"># 	centers = [diff_X[clusters == 0].mean(), diff_X[clusters == 1].mean()]</span>
<span class="c1"># 	sweep_marker = np.argmin(centers)</span>
<span class="c1"># 	end_line_indices = list(np.where(clusters == sweep_marker)[0] + 1)</span>
<span class="c1"># 	end_line_indices.append(n)</span>
<span class="c1"># 	start_of_line = 0</span>
<span class="c1"># 	for end_of_line in end_line_indices:</span>
<span class="c1"># 		mean_y = np.mean(fixation_XY[start_of_line:end_of_line, 1])</span>
<span class="c1"># 		line_i = np.argmin(abs(line_Y - mean_y))</span>
<span class="c1"># 		fixation_XY[start_of_line:end_of_line, 1] = line_Y[line_i]</span>
<span class="c1"># 		start_of_line = end_of_line</span>
<span class="c1"># 	return fixation_XY</span>

<span class="c1">######################################################################</span>
<span class="c1"># STRETCH</span>
<span class="c1">#</span>
<span class="c1"># Lohmeier, S. (2015). Experimental evaluation and modelling of the</span>
<span class="c1">#   comprehension of indirect anaphors in a programming language</span>
<span class="c1">#   (Master’s thesis). Technische Universität Berlin.</span>
<span class="c1">#</span>
<span class="c1"># http://www.monochromata.de/master_thesis/ma1.3.pdf</span>
<span class="c1">######################################################################</span>

<div class="viewcode-block" id="stretch">
<a class="viewcode-back" href="../source/driftAlgorithms.html#driftAlgorithms.stretch">[docs]</a>
<span class="k">def</span> <span class="nf">stretch</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">,</span> <span class="n">line_Y</span><span class="p">,</span> <span class="n">scale_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">),</span> <span class="n">offset_bounds</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)):</span>
	<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">)</span>
	<span class="n">fixation_Y</span> <span class="o">=</span> <span class="n">fixation_XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">fit_lines</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">return_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="n">candidate_Y</span> <span class="o">=</span> <span class="n">fixation_Y</span> <span class="o">*</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">corrected_Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">fixation_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
			<span class="n">line_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">line_Y</span> <span class="o">-</span> <span class="n">candidate_Y</span><span class="p">[</span><span class="n">fixation_i</span><span class="p">]))</span>
			<span class="n">corrected_Y</span><span class="p">[</span><span class="n">fixation_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">line_Y</span><span class="p">[</span><span class="n">line_i</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">return_correction</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">corrected_Y</span>
		<span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">candidate_Y</span> <span class="o">-</span> <span class="n">corrected_Y</span><span class="p">))</span>

	<span class="n">best_fit</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">fit_lines</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="n">scale_bounds</span><span class="p">,</span> <span class="n">offset_bounds</span><span class="p">])</span>
	<span class="n">fixation_XY</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_lines</span><span class="p">(</span><span class="n">best_fit</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">return_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">fixation_XY</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># WARP</span>
<span class="c1">#</span>
<span class="c1"># Carr, J. W., Pescuma, V. N., Furlan, M., Ktori, M., &amp; Crepaldi, D.</span>
<span class="c1">#   (2021). Algorithms for the automated correction of vertical drift</span>
<span class="c1">#   in eye-tracking data. Behavior Research Methods.</span>
<span class="c1">#</span>
<span class="c1"># https://doi.org/10.3758/s13428-021-01554-0</span>
<span class="c1"># https://github.com/jwcarr/drift</span>
<span class="c1">######################################################################</span>

<div class="viewcode-block" id="warp">
<a class="viewcode-back" href="../source/driftAlgorithms.html#driftAlgorithms.warp">[docs]</a>
<span class="k">def</span> <span class="nf">warp</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">,</span> <span class="n">word_XY</span><span class="p">):</span>
	<span class="n">_</span><span class="p">,</span> <span class="n">dtw_path</span> <span class="o">=</span> <span class="n">dynamic_time_warping</span><span class="p">(</span><span class="n">fixation_XY</span><span class="p">,</span> <span class="n">word_XY</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">fixation_i</span><span class="p">,</span> <span class="n">words_mapped_to_fixation_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dtw_path</span><span class="p">):</span>
		<span class="n">candidate_Y</span> <span class="o">=</span> <span class="n">word_XY</span><span class="p">[</span><span class="n">words_mapped_to_fixation_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
		<span class="n">fixation_XY</span><span class="p">[</span><span class="n">fixation_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode</span><span class="p">(</span><span class="n">candidate_Y</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">fixation_XY</span></div>


<div class="viewcode-block" id="mode">
<a class="viewcode-back" href="../source/driftAlgorithms.html#driftAlgorithms.mode">[docs]</a>
<span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
	<span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">count</span><span class="p">)</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># Dynamic Time Warping adapted from https://github.com/talcs/simpledtw</span>
<span class="c1"># This is used by the COMPARE and WARP algorithms</span>
<span class="c1">######################################################################</span>

<div class="viewcode-block" id="dynamic_time_warping">
<a class="viewcode-back" href="../source/driftAlgorithms.html#driftAlgorithms.dynamic_time_warping">[docs]</a>
<span class="k">def</span> <span class="nf">dynamic_time_warping</span><span class="p">(</span><span class="n">sequence1</span><span class="p">,</span> <span class="n">sequence2</span><span class="p">):</span>
	<span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence1</span><span class="p">)</span>
	<span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence2</span><span class="p">)</span>
	<span class="n">dtw_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
	<span class="n">dtw_cost</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
	<span class="n">dtw_cost</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
	<span class="n">dtw_cost</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n2</span><span class="p">):</span>
			<span class="n">this_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">sequence1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">sequence2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
			<span class="n">dtw_cost</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_cost</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">dtw_cost</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtw_cost</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">dtw_cost</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
	<span class="n">dtw_cost</span> <span class="o">=</span> <span class="n">dtw_cost</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
	<span class="n">dtw_path</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span><span class="p">)]</span>
	<span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">dtw_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
		<span class="n">possible_moves</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">possible_moves</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtw_cost</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">possible_moves</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtw_cost</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">possible_moves</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtw_cost</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">best_move</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">possible_moves</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">best_move</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
			<span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
		<span class="k">elif</span> <span class="n">best_move</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
	<span class="n">dtw_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">dtw_cost</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtw_path</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">fix8</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Naser Al Madi, Brett Torra, Agnes Li, Najam Tariq, Ricky Peng.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>